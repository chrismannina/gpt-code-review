import openai
import requests
import os
from dotenv import load_dotenv

load_dotenv()

# Read OpenAI API key from environment variable
openai.api_key = os.environ.get("OPENAI_API_KEY")

# Model for API requests
model = "gpt-3.5-turbo"

# GitLab API endpoint and personal access token
gitlab_url = os.environ.get("GITLAB_URL")
access_token = os.environ.get("GITLAB_ACCESS_TOKEN")
project_id = os.environ.get("GITLAB_PROJECT_ID")

# Headers for API requests
headers = {
    "Private-Token": access_token
}

# API Endpoint to fetch commits
commits_url = f"{gitlab_url}/api/v4/projects/{project_id}/repository/commits"
commits_response = requests.get(commits_url, headers=headers)

# Check if the request was successful
if commits_response.status_code != 200:
    print(f"Failed to fetch commits: {commits_response.status_code}")
    exit(1)

try:
    commit_data = commits_response.json()
except json.JSONDecodeError:
    print("Failed to decode JSON. Status code:", commits_response.status_code)
    print("Response text:", commits_response.text)

# Get the most recent commit
commit = commit_data[0]

# # Iterate through each commit
# for commit in commit_data:
# Get the commit's diff
commit_diff_url = f"{gitlab_url}/api/v4/projects/{project_id}/repository/commits/{commit['id']}/diff"
commit_diff_response = requests.get(commit_diff_url, headers=headers)
commit_diff_data = commit_diff_response.json()

# Extract code changes and perform the review
for diff in commit_diff_data:
    if 'new_path' in diff and diff['new_path'].endswith('.py'): # We're only reviewing Python files here
        code_changes = diff['diff']

        # Set up the conversation for the chat model
        messages = [
            {"role": "system", "content": "You are a helpful assistant that reviews code."},
            {"role": "user", "content": f"Please see the following code changes, and provide a detailed and helpful code review with examples of code improvements where possible:\n\n{code_changes}"},
        ]

        # Use the ChatCompletion endpoint
        response = openai.ChatCompletion.create(
            model=model,
            messages=messages,
            max_tokens=400,
        )

        analysis = f"This comment is auto-generated by OpenAI {model} : {response['choices'][0]['message']['content']}"
        print(analysis)
        # Make comment on commit with the analysis
        comment_url = f"{gitlab_url}/api/v4/projects/{project_id}/repository/commits/{commit['id']}/comments"
        comment_data = {
            "note": analysis
        }
        requests.post(comment_url, headers=headers, data=comment_data)

# # Get all merge requests for a specific project
# mr_url = f"{gitlab_url}/projects/{project_id}/merge_requests?state=opened"
# mr_response = requests.get(mr_url, headers=headers)
# mr_data = mr_response.json()

# # Iterate through each merge request
# for mr in mr_data:
#     # Get the merge request's code changes
#     mr_changes_url = f"{gitlab_url}/projects/{project_id}/merge_requests/{mr['iid']}/changes"
#     mr_changes_response = requests.get(mr_changes_url, headers=headers)
#     mr_changes_data = mr_changes_response.json()
#     code_changes = mr_changes_data['changes']

#     # Set up the conversation for the chat model
#     messages = [
#         {"role": "system", "content": "You are a helpful assistant that reviews code."},
#         {"role": "user", "content": f"Please review the following code changes:\n\n{code_changes}"},
#     ]

#     # Use the ChatCompletion endpoint
#     response = openai.ChatCompletion.create(
#       model=model,
#       messages=messages,
#       max_tokens=400,
#     )

#     analysis = f"This comment is auto-generated by OpenAI {model} : {response['choices'][0]['message']['content']}"

#     # Make comment on merge request with the analysis
#     comment_url = f"{gitlab_url}/projects/{project_id}/merge_requests/{mr['iid']}/notes"
#     comment_data = {
#         "body": analysis
#     }
#     requests.post(comment_url, headers=headers, data=comment_data)
